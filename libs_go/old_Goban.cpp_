#include "Goban.h"
#include <stdio.h>
#include <math.h>

Goban::Goban(unsigned int size, bool draw_enabled, float komi)
{
	this->size = size;
	this->draw_enabled = draw_enabled;
	this->moves_count = 0;
	this->komi = komi;

	board.resize(size);

	for (unsigned int y = 0; y < board.size(); y++)
	 board[y].resize(size);

	for (unsigned int y = 0; y < board.size(); y++)
	for (unsigned int x = 0; x < board[y].size(); x++)
		board[y][x] = GO_PLAYER_EMPTY;


	legal.resize(size);

	for (unsigned int y = 0; y < legal.size(); y++)
	 legal[y].resize(size);

	for (unsigned int y = 0; y < legal.size(); y++)
	for (unsigned int x = 0; x < legal[y].size(); x++)
		legal[y][x] = true;


	freedoms.resize(size);

	for (unsigned int y = 0; y < freedoms.size(); y++)
	 freedoms[y].resize(size);

	for (unsigned int y = 0; y < freedoms.size(); y++)
	for (unsigned int x = 0; x < freedoms[y].size(); x++)
		freedoms[y][x] = true;


	territory.resize(size);

	for (unsigned int y = 0; y < territory.size(); y++)
	 territory[y].resize(size);

	for (unsigned int y = 0; y < territory.size(); y++)
	for (unsigned int x = 0; x < territory[y].size(); x++)
		territory[y][x] = 0;
}

Goban::~Goban()
{

}



int Goban::play(GoPlayer &black, GoPlayer &white)
{
	if (draw_enabled)
		draw();

	find_legal_moves(GO_PLAYER_BLACK);
	if (legal_moves.size() == 0)
	 return GOBAN_BLACK_NO_LEGAL_MOVES;

	black.set_board_status(board, GO_PLAYER_BLACK, legal_moves);
	black.play();
	GoMove black_move = black.get_move();

	if (is_legal_move(black_move) == false)
	 return GOBAN_BLACK_ILLEGAL_MOVE;

	if (black_move.pass() == false)
		play_move(black_move);

	moves.push_back(black_move);
	positions.push_back(board);

	prev_move = black_move;


	if (draw_enabled)
		draw();



	find_legal_moves(GO_PLAYER_WHITE);
	if (legal_moves.size() == 0)
	 return GOBAN_WHITE_NO_LEGAL_MOVES;

  white.set_board_status(board, GO_PLAYER_WHITE, legal_moves);
	white.play();
	GoMove white_move = white.get_move();


	if (is_legal_move(white_move) == false)
	 return GOBAN_WHITE_ILLEGAL_MOVE;


	if (white_move.pass() == false)
		play_move(white_move);

	moves.push_back(white_move);
	positions.push_back(board);

	prev_move = white_move;

	moves_count++;

	if (draw_enabled)
		draw();

	if (black_move.pass() && white_move.pass())
	  return GOBAN_GAME_END;

	if (fabs(compute_score()) > size*size*0.70)
		return GOBAN_GAME_END;

	if (moves_count*2 > size*size*0.8)
		return GOBAN_GAME_END;


	return GOBAN_GAME_PLAYING;
}

void Goban::draw()
{
	for (unsigned int y = 0; y < board.size(); y++)
	{
		for (unsigned int x = 0; x < board[y].size(); x++)
		{
			int v = board[y][x];

			switch (v)
			{
				case GO_PLAYER_EMPTY: printf("."); break;
				case GO_PLAYER_BLACK: printf("B"); break;
				case GO_PLAYER_WHITE: printf("W"); break;
			}

			printf(" ");
		}
		printf("\n");
	}

	printf("\n\n");
}

void Goban::find_legal_moves(int player)
{
	for (unsigned int y = 0; y < board.size(); y++)
	for (unsigned int x = 0; x < board[y].size(); x++)
	if (board[y][x] == GO_PLAYER_EMPTY)
	 	legal[y][x] = true;
	else
	 	legal[y][x] = false;

	//avoid suicide
	for (unsigned int y = 0; y < board.size(); y++)
	for (unsigned int x = 0; x < board[y].size(); x++)
	if (board[y][x] == GO_PLAYER_EMPTY)
	if (count_neighbour_fields(x, y, GO_PLAYER_EMPTY) == 0)
	{
		board[y][x] = player;

		compute_freedoms();

		int black_captured = count_captured(GO_PLAYER_BLACK);
		int white_captured = count_captured(GO_PLAYER_WHITE);

		if (player == GO_PLAYER_BLACK)
		{
		 if ((black_captured != 0)&&(white_captured == 0))
		  legal[y][x] = false;
		}
		else
		{
		 if ((white_captured != 0)&&(black_captured == 0))
		  legal[y][x] = false;
		}

		board[y][x] = GO_PLAYER_EMPTY;
	}

	//avoid ko
	int prev = positions.size()-2;
	if (prev >= 0)
	{
		for (unsigned int y = 0; y < board.size(); y++)
		for (unsigned int x = 0; x < board[y].size(); x++)
		if (legal[y][x] == true)
		if (near_move(prev_move.x(), prev_move.y(), x, y))
		{
			board_tmp = board;

			board[y][x] = player;

			compute_freedoms();

			if (player == GO_PLAYER_BLACK)
				capture_stones(GO_PLAYER_WHITE);
			else
				capture_stones(GO_PLAYER_BLACK);

			if (compare_board(board, positions[prev]))
			{
				legal[y][x] = false;
			}

			board = board_tmp;
		}
	}


	legal_moves.clear();

	GoMove move(true, player);
	legal_moves.push_back(move);

	for (unsigned int y = 0; y < board.size(); y++)
	for (unsigned int x = 0; x < board[y].size(); x++)
	if (legal[y][x] == true)
	{
	 GoMove move(x, y, player);
	 legal_moves.push_back(move);
	}


}

void Goban::play_move(GoMove &move)
{
	board[move.y()][move.x()] = move.player();

	compute_freedoms();

	if (move.player() == GO_PLAYER_BLACK)
		capture_stones(GO_PLAYER_WHITE);
	else
		capture_stones(GO_PLAYER_BLACK);
}

bool Goban::is_legal_move(GoMove &move)
{
	for (unsigned int i = 0; i < legal_moves.size(); i++)
	 if (legal_moves[i] == move)
	   return true;

	return false;
}

int Goban::count_neighbour_fields(int x, int y, int player)
{
 	int result = 0;

	if (x > 0)
	if (board[y][x-1] == player)
	 result++;

	if (x+1 < (int)size)
	if (board[y][x+1] == player)
	 result++;

	if (y > 0)
	if (board[y-1][x] == player)
	 result++;

	if (y+1 < (int)size)
	if (board[y+1][x] == player)
	 result++;

	return result;
}



int Goban::count_freedom_fields(int x, int y, int player)
{
 	int result = count_neighbour_fields(x, y, GO_PLAYER_EMPTY);

	if (x > 0)
	if (board[y][x-1] == player)
	if (freedoms[y][x-1])
	 result++;

	if (x+1 < (int)size)
	if (board[y][x+1] == player)
	if (freedoms[y][x+1])
	 result++;

	if (y > 0)
	if (board[y-1][x] == player)
	if (freedoms[y-1][x])
	 result++;

	if (y+1 < (int)size)
	if (board[y+1][x] == player)
	if (freedoms[y+1][x])
	 result++;

	return result;
}



void Goban::compute_freedoms()
{
	for (unsigned int y = 0; y < board.size(); y++)
	for (unsigned int x = 0; x < board[y].size(); x++)
	if (board[y][x] == GO_PLAYER_EMPTY)
	 	freedoms[y][x] = true;
	else
	 	freedoms[y][x] = false;


	bool change = true;
	while (change)
	{
	 	change = false;

		for (unsigned int y = 0; y < board.size(); y++)
		for (unsigned int x = 0; x < board[y].size(); x++)
		if (board[y][x] != GO_PLAYER_EMPTY)
	 	if (freedoms[y][x] == false)
		{
		  if (count_freedom_fields(x, y, board[y][x]) > 0)
		  {
			freedoms[y][x] = true;
			change = true;
		  }
		}
	}
}

int Goban::count_captured(int player)
{
	int result = 0;

	for (unsigned int y = 0; y < board.size(); y++)
	for (unsigned int x = 0; x < board[y].size(); x++)
	if (board[y][x] == player)
	if (freedoms[y][x] == false)
		result++;

	return result;
}

void Goban::capture_stones(int player)
{
	for (unsigned int y = 0; y < board.size(); y++)
	for (unsigned int x = 0; x < board[y].size(); x++)
	if (board[y][x] == player)
	if (freedoms[y][x] == false)
	 board[y][x] = GO_PLAYER_EMPTY;
}


float Goban::compute_score()
{
	int radius = 4;

	for (unsigned int y = 0; y < board.size(); y++)
	for (unsigned int x = 0; x < board[y].size(); x++)
	{
		territory[y][x] = 0;

		if (board[y][x] == GO_PLAYER_BLACK)
			territory[y][x] = radius;

		if (board[y][x] == GO_PLAYER_WHITE)
			territory[y][x] = -radius;
	}


	bool change = true;
	while (change)
	{
		change = false;
		for (unsigned int y = 0; y < board.size(); y++)
		for (unsigned int x = 0; x < board[y].size(); x++)
			if (territory[y][x] == 0)
			{
				int max = find_max_territory_value(x, y);
				int min = find_min_territory_value(x, y);


				if (max > 0)
					max = max-1;
				else
					max = 0;

				if (min < 0)
					min = min+1;
				else
					min = 0;

				if (abs(max) > abs(min))
				{
					if (max != 0)
					{
						territory[y][x] = max;
						change = true;
					}
				}
				else
				{
					if (min != 0)
					{
						territory[y][x] = min;
						change = true;
					}
				}

			}
	}


	int black_territory = 0;
	int white_territory = 0;

	for (unsigned int y = 0; y < board.size(); y++)
	for (unsigned int x = 0; x < board[y].size(); x++)
		if (territory[y][x] > 0)
			black_territory++;

	for (unsigned int y = 0; y < board.size(); y++)
	for (unsigned int x = 0; x < board[y].size(); x++)
		if (territory[y][x] < 0)
			white_territory++;

	float result = black_territory - white_territory - komi;

	return result;
}


int Goban::find_max_territory_value(int x, int y)
{
	int result = 0;

	if (x > 0)
	if (territory[y][x-1] > result)
		result = territory[y][x-1];

	if (x+1 < (int)size)
	if (territory[y][x+1] > result)
	 result = territory[y][x+1];

	if (y > 0)
	if (territory[y-1][x] > result)
	 result = territory[y-1][x];

	if (y+1 < (int)size)
	if (territory[y+1][x] > result)
	 result = territory[y+1][x];

	return result;
}


int Goban::find_min_territory_value(int x, int y)
{
	int result = 0;

	if (x > 0)
	if (territory[y][x-1] < result)
	 result = territory[y][x-1];

	if (x+1 < (int)size)
	if (territory[y][x+1] < result)
	 result = territory[y][x+1];

	if (y > 0)
	if (territory[y-1][x] < result)
	 result = territory[y-1][x];

	if (y+1 < (int)size)
	if (territory[y+1][x] < result)
	 result = territory[y+1][x];

	return result;
}

bool Goban::compare_board(GoBoard &board_a, GoBoard &board_b)
{
	for (unsigned int y = 0; y < board_a.size(); y++)
		for (unsigned int x = 0; x < board_a[y].size(); x++)
			if (board_a[y][x] != board_b[y][x])
				return false;

	return true;
}

bool Goban::near_move(int prev_x, int prev_y, int x, int y)
{
	if (abs(prev_x - x) == 1)
		return true;

	if (abs(prev_y - y) == 1)
		return true;

	return false;
}
